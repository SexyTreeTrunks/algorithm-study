# 완전탐색0
모든 경우의 수를 만들어보고 탐색하는방법
- Brute Force
- BFS
- 재귀호출
- 비트마스크
- 순열
- 백트래킹

### 그냥다해보기(Brute Force)
경우의수가 몇가지가 나오는지 알아야함
(가능한 경우의수가 너무 많으면 탐색을할수 없기때문)

#### 날짜계산(1476)
##### 방법1. for문 (brute force 이용)
```java
static int getYear(int E, int S, int M) {
  int e, s, m, year;
  e = s = m = year = 0;
  for (int i = 0; true; i++) {
    e++;
    if (e > 15)
      e = 1;
    s++;
    if (s > 28)
      s = 1;
    m++;
    if (m > 19)
      m = 1;
    year++;
    if (e == E && s == S && m == M)
      break;
  }
  return year;
}
```
##### 방법2. 수학적접근(나머지정리 이용)
**값이 특정범위로 반복되는 형태 --> 나머지**
각 E,S,M 범위에 -1을 해주면 E,S,M값을 나머지로 나타낼수 있음
구하는 년도를 Y라고 할때 Y는 아래 식을 모두 만족하는 최소값
Y % 15 = E
Y % 28 = S
Y % 19 = M
근데 이것도 방법1이랑 시간복잡도는 똑같음. 맞을때까지 year증가시켜주는거니깐

```java
static int getYear(int E, int S, int M) {
  E--;S--;M--;
  int year = 0;
  while (true) {
    if ((year % 15 == E) && (year % 28 == S) && (year % 19 == M))
      return year + 1;
    year++;
  }
}
```

#### 리모컨(1107)
문제는 안품. 대신 백준 코드와 풀이과정 이해

##### 풀이과정
- +,-값 만으로 채널이동해야 할 경우 고려
  + 현재 채널(100번)에서 +,-만으로 이동했을때 최소값인 경우 EX) 101
  + 고장난 숫자가 많은경우 EX) 입력가능한문자가 1,5 인데 이동할채널은 500000일때
- N과 가까운 채널(C)을 입력한뒤 +,-로 이동해야하는 경우
  + 입력숫자(C)에 망가진 숫자가 있는지 확인
    * 망가진 숫자가 없으면 입력숫자의 길이(len)가 최소가되는 C 구하기
    * 망가진 숫자가 있으면 입력숫자의 길이(len) + 이동횟수(|C-N|)가 최소가되는 C구하기

코드는 생략

#### 1, 2, 3 더하기(9095)
숫자를 정수의 더하기로 표현하는 방법의 수 구하기
정말 모든 경우의 수를 다 해보는 방법밖에 없음(n중 for문으로 구현)
코드는 어짜피 for문밖에 없으므로 생략함

### 완전탐색과 순열
입력이 n개일때의 경우를 모두 다 해야하고 순서도 고려해야하는 문제
순열문제는 시간복잡도에 n!이 기본적으로 들어가기때문에 입력값의 범위가 제한되어있음
(보통 10이하)

#### 차이를 최대로(10819)
주어진 식을 최대로 하는 순열 찾기
- 시간복잡도는 O(n!), n<=8 이므로 다 해봐도 오래 안걸림
- 첫번째순열부터 마지막순열까지 다 수식을 계산해봐서 최대값을 구하면됨
  + *첫번째순열*부터 수식을 계산하기위해 *정렬*이 필요

##### 수도코드
- 순열 정렬 -- O(n*logn)
- do { answer = max(answer,calculate(순열)) } until has nextPermutation -- O(n!)

**※ 주의사항**
기존 nextPermutation함수는 순열에 중복값이 들어왔을때를 고려하지 않은 코드임
따라서 코드를 바꿔줘야하는데 i값 구할때 while조건을 arr[i] <= arr[i-1] 로 바꿔주면됨

#### 외판원 순회2(10971)
모든 도시를 순회(도시를 한번씩만 거쳐야함)하는 최소비용 구하기
i도시에서 j도시로 이동할때 비용은 배열로 표현함

* 첫 도시를 각 다르게하여 각 시작도시마다 최소비용을 찾아야함
  - n(도시수) x n!(최소비용찾기) ==> O(n x n!)

* 하지만 문제에서 도시를 다 거치면 시작도시로 돌아오므로 시작도시를 고정시켜도 됨
  - n(도시수) x (n-1)!(도시 하나 고정했으므로) ==> O(n!)

#### 로또(6603)
순열에 중복값이 있을때 처리 필요
중복이 있을때 순열의 총 개수는 n! / a!b!c!.. (a,b,c는 중복된문자의 개수)
