# 완전탐색0

### 비트마스트
비트연산을 사용해서 부분집합을 표현하는 방법

#### 비트연산 개꿀팁
- A<<B = A x 2^B
- A>>B = A / 2^B
- (A+B)/2 = (A+B) >> 1 (∵ >>1 == /2)
- (N % 2 == 1) = (N & 1)
> ∵ 홀짝수 판별하려면 맨마지막비트가 0인지1인지만 판별하면됨
 1은 맨마지막비트를 제외한 비트가 모두 0이므로 N과 &연산을하면 N의 맨마지막비트가 1일때(홀수) TRUE, 마지막비트가 0일때(짝수) FALSE 임


#### 비트마스크로 부분집합 표현하기
부분집합을 나타내는것은 어떠한 수가 집합에 있는지(1) 없는지(0) 판단하는 것임
이진수 1000111010값을 예로 들면
2^1,2^3,2^4,2^5,2^9 에 1이 있으므로 {1,3,4,5,9} 라는 부분집합으로 나타낼수있다

#### 부분집합에 수가 포함되어있는지 검사
이진수로 표현한 값에서 검사하고싶은 비트의 값이 1인지 알아내면됨(&)
1000111010를 예로 들면,

해당부분집합에 4가 있는지 검사하고싶다면
1000111010 & 000000**1**000 → 이렇게 0인지 아닌지 검사하면됨

해당부분집합에 X가 있는지 검사하고싶다면
X만 포함한 부분집합 만들기 → 1<<X (X번째 비트만 1이고 나머지는 0)
부분집합 검사하기 → 부분집합값 & (1<<X)

#### 부분집합에 수 추가하기
OR 연산을 이용하면됨

**부분집합수 | (1<<X)**

#### 부분집합에 수 제거하기
NOT 이용

먼저 제거하고싶은 비트 마스크값 추출 → 1<<X
해당 비트의 값 토글(값제거) → ~(1<<X)
NOT 연산을 한 비트마스크와 부분집합수 AND연산 → 부분집합수 & ~(1<<X)

#### 전체집합과 공집합
전체집합 : 이진수값이 모두 1(N개의 비트가 모두 1) → (1<<N) - 1
공집합 : 0

#### 왜 비트마스크씀?
어떤 집합을 배열의 인덱스로 표현할수 있기때문
상태 다이나믹할때 유용 --> 재귀호출없이 for문만으로 부분집합의 상태 순회/변경 가능


### 순열
1-N 까지의 수로 이루어진 순열(수의 순서)

#### 다음순열
순열을 사전순으로 나열했을때 다음에 올 순열

1. A[i-1] < A[i] 인것중에 가장 큰 i를 찾기 -- O(N)
> ##### ex) 7 2 3 6 5 4 1 에서
- 2 3, 3 6 이 서로 인접해있으면서 오른쪽수가 더 큼 (A[i-1] < A[i])
- 이중 6이 제일 크므로 i=4
- _예시가되는 순열에서 6을 시작으로 감소함(7 2 3 **6 5 4 1**)_

**※ 코드 구현시**
코드로 구현할때는 위에 설명처럼 첫 element부터 검사하는것이 아니라
끝 element부터 검사하여 감소순열이 아닌 값을 찾으면됨

2. j>=i 이면서 A[j] > A[i-1]를 만족하는 가장 큰 j를 찾기 -- O(N)
> ##### ex) 7 2 3 6 5 4 1
- 6과 6 오른쪽에있는 수 6 5 4 1 (j>=i)
- 이중 3(A[i-1])보다 큰 값중 **인덱스가 제일 큰값**이 4이므로 j=5 (A[j] > A[i-1])

**※ 코드 구현시**
이것 역시 맨 끝에서부터 검사하여 A[i-1]보다 작으면 다음으로 넘어가고
큰값이 있으면 그 값을 j값으로 지정하면 됨

3. A[j]와 A[i-1] swap -- O(1)
7 2 3 6 5 4 1 → 7 2 4 6 5 3 1

4. A[i]부터 순열을 뒤집음(역순으로) -- O(N)
7 2 4 **6** 5 3 1 → 7 2 4 **1 3 5 6**

이렇게 다음 순열을 찾는 코드는 1~4 과정을 거쳐서 구현하면되고
함수형태로 구현하여 다음순열이 있다면 TRUE, 다음순열이 없으면 FALSE를 리턴함

```java
boolean nextPermutation(int arr[]) {
  if(last permutation)
    return false;
  else
    return true;
}
```

#### 순열의 순서
순열을 사전순으로 나열했을때 해당수열이 몇번째 수열인지 혹은 임의번째의 수열을 구하는 문제

#### 이 순열은 몇번째?
##### EX) 5 2 4 7 6 3 1
- 맨 첫번째 순열의 가중치는 (7-1)!, 1,2,3,4로 시작하는 수열 앞에두므로 자릿수는 4

	+ 6! x 4

- 두번째 순열은 (7-2)!, 5 1 로 시작하는 수열 앞에 둠

	+ 5! x 1

- 3번쨰는 (7-3)!, 5 2 1, 5 2 3 으로 시작하는 수열 앞에 둠

	+ 4! x 2

- 4번째는 (7-4)!, 5 2 4 1, 5 2 4 3, 5 2 4 6

	+ 3! x 3

- 5번째는 (7-5)!, 5 2 4 7 1, 5 2 4 7 3

	+ 2! x 2

- 6번째는 (7-6)!, 5 2 4 7 6 1

	+ 1 x 1

이렇게 해서 각 자리에서 계산된 값 다 더하면 됨

#### 몇번째 순열은 어떤 순열?
위의 과정을 반대로 이용하면됨
##### EX) 3071번째 순열 찾기
- 첫번째 값 찾기위해 음수가될때까지 3071에서 6! 빼줌

	+ 3071 - 6! x 5 > 0 이므로 첫번째 수는 5

...
